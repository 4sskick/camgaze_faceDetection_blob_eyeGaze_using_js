
<html>
    <head>
    	<link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet">
        <script text="text/javascript" src="/camgaze.js/js/jsfeat.js"></script>
        <script text="text/javascript" src="/camgaze.js/js/compatibility.js"></script>
        <script text="text/javascript" src="/camgaze.js/js/camgaze.js"></script>
        <script text="text/javascript" src="/camgaze.js/cascades/eye.js"></script>
        <script text="text/javascript" src="http://cloud.github.com/downloads/harthur/brain/brain-0.6.0.js"></script>
        <script type="text/javascript" src="http://codeorigin.jquery.com/jquery-2.0.3.min.js"></script>
        <style>
        	button {
        		top: 50%;
        		left: 47%;
        		position: fixed;
        	}
        </style>
    </head>
    <body>
		<button class="btn btn-primary btn-lg" id="startButton" onclick="startButtonClicked()">
			Start
		</button>
        <canvas id="mainCanvas"></canvas>
        <video style="display:none;" autoplay></video>
        <script text="text/javascript">

            var numberOfTestPoints = 10;
            var distList = new Array();

            function getRandomInt (min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function getDistList() {
                return distList;
            }

			function startButtonClicked() {

				$("#startButton").remove();
				//alert("balls");
				// width and height of the canvas
				var height = document.height;
				var width = document.width;

				var cGaze = new camgaze.Camgaze(
					width, 
					height, 
					"mainCanvas",
					true
				);

				// height and width here refer to the video width and height
				var eyeTracker = new camgaze.EyeTracker(640, 480);
				var eyeFilter = new camgaze.EyeFilter();
				var eyeCalibrator = new camgaze.LinearCalibrator(
					0, width,
					0, height
				);

				var canvas = document.getElementById('mainCanvas');

				var drawer = new camgaze.drawing.CanvasDrawer(
					"mainCanvas",
					document.width,
					document.height
                );

                // counts the number of clicks the user does
                // onto the canvas
                var clickCounter = 0;

                // points shown to the user for calibration
				var calibrationPoints = [
					new camgaze.structures.Point(
						33, 
						40 
					),
					new camgaze.structures.Point(
						document.width - 50, 
						40
					),
					new camgaze.structures.Point(
						33, 
						document.height - 70
					),
					new camgaze.structures.Point(
						document.width - 50, 
						document.height - 70
					)
				];

                var calibPoint
                var testPoint;
                var drawPoint;
                var calibList = new Array();
                var net = new brain.NeuralNetwork();
                canvas.addEventListener("click", function (e) {
                    if (clickCounter > 3) {
                        distList.push(testPoint.distTo(drawPoint));
                    }

                    if(clickCounter < calibrationPoints.length) {
                        calibList.push({input: calibPoint.toList(), output: calibrationPoints[clickCounter].toList()});
                    }


                    if (clickCounter == 3) {
                        net.train(calibList);
                        alert("Start the test");
                    }

                    if (clickCounter == numberOfTestPoints + 3) {
                        alert("You are done!");

                    }


                    testPoint = new camgaze.structures.Point(
                        getRandomInt(20, width - 20),
                        getRandomInt(20, height - 20)
                    );
					clickCounter++;
				});

				var frameOp = function (image_data, video, canvasDrawer) {
					canvasDrawer.clearAll()
					canvasDrawer.clearCanvas()
					var trackingData = eyeTracker.track(image_data, video);
					var gazeList = eyeFilter.getFilteredGaze(trackingData);
					var avgLookingPoint = eyeFilter.getAverageLookingPoint(
						trackingData
					);

                    // Determines if a calibration point should be
                    // shown on the screen
                    if (clickCounter < 4) {
					    canvasDrawer.drawCircle(
						    calibrationPoints[clickCounter],
						    70,  // radius
						    -1, // line width (filled)
						    "green"
					    );
                    }
                    // Gaze Metric
					calibPoint = new camgaze.structures.Point(
						parseInt(
							(document.width / 2).toFixed(0)
						) - 3 * avgLookingPoint.x,
						parseInt(
							(document.height / 2).toFixed(0)
						) + 3 * avgLookingPoint.y
                    );

                    // determines where to draw the looking point
                    switch (clickCounter) {
						case 0:
							drawPoint = eyeCalibrator.setTopLeft(
								calibPoint
                            );
							break;
						case 1:
							drawPoint = eyeCalibrator.setTopRight(
								calibPoint
                            );
							break;
						case 2:
							drawPoint = eyeCalibrator.setBottomLeft(
								calibPoint
							);
							break;
						case 3:
							drawPoint = eyeCalibrator.setBottomRight(
								calibPoint
                            );
                            break;
                        default:
							//drawPoint = eyeCalibrator.getMappedPoint(
							//	calibPoint
                            //);

                            drawPoint = net.run(calibPoint.toList());
                            console.log(drawPoint);
                    }

                    if (drawPoint.x > width) {
                        drawPoint.x = width;
                    }

                    if (drawPoint.y > height) {
                        drawPoint.y = height;
                    }

                    if (drawPoint.x < 0) {
                        drawPoint.x = 0;
                    }

                    if (drawPoint.y < 0) {
                        drawPoint.y = 0;
                    }

					canvasDrawer.drawCircle(
						drawPoint,
						10,
						-1,
						"blue"
					);

                    if (
                        clickCounter < numberOfTestPoints + 4 &&
                        clickCounter > 3
                    ) {
                        canvasDrawer.drawCircle(
                            testPoint,
                            20,
                            -1,
                            "black"
                        );
                    }

					if (trackingData.eyeList.length > 0) {
						gazeList.forEach(
							function (eye) {
								canvasDrawer.drawCircle(
									eye.centroid.unfiltered,
									5,  // radius
									-1, // line width (filled)
									"red"
								);
							}
						);
					}
					canvasDrawer.drawAll(false);
                };

                // sets the operation at each interation
				cGaze.setFrameOperator(frameOp);
			} 
		</script>
</html>

